### Copyright		Teodora-Anca Plopeanu 312CA


# Tema #3 - Editor de imagini

In cadrul acestei teme, am implementat un **editor de imagini**, ce efectueaza diverse operatii asupra fisierelor de format **NetPBM**.

O imagine in formatul NetPBM are urmatoarea structura:
 - un numar magic, de forma **Px**, unde x poate avea valori de la 1 la 6; acesta precizeaza tipul imaginii (alb-negru, grayscale sau color), precum si modalitatea de stocare (text sau binar);
 - latimea si inaltimea imaginii (in pixeli);
 - valoarea maxima a unui pixel;
 - imaginea (valorile pixelilor).
 
 *Obs.:* In cazul in care imaginea este in format color (P3 sau P6), fiecarui pixel ii corespund cate trei valori, cate una pentru fiecare culoare din spectrul RGB.

Aceste detalii au fost incorporate in cadrul structurii *PBM*, din program.

In continuare, voi descrie modul de functionare al fiecarei functii in parte:


## LOAD < fisier >

**Incarca** in memoria programului **fisierul** (PGM sau PPM) primit drept argument.

Daca in memoria programului exista deja o imagine incarcata anterior, memoria alocata acesteia va fi eliberata, cu ajutorul functiei *free*.

Dupa care, deschidem fisierul pentru citire in format text, pentru a scana numarul magic, precum si dimensiunile imaginii (width, height si max_value).

Inchidem fisierul si il redeschidem, corespunzator cu valoarea numarului magic (text sau binar), ulterior citind valorile pixelilor, cu ajutorul functiilor *fscanf*, respectiv *fread*. 

Actualizam dimensiunile din structura, precum si statusul *is_loaded*.

Daca procedeul a intampinat dificultati pe parcursul rularii, mesajul afisat va fi **Failed to load < fisier >**. In caz contrar, vom printa **Loaded < fisier >**


## SELECT < x1 > < y1 > < x2 > < y2 >

Realizeaza o **selectie** a imaginii, comenzile ulterioare urmand sa fie aplicate doar pe aceasta, nu pe intreaga imagine (cu anumite exceptii).

Daca nu exista nicio imagine incarcata in memorie, mesajul afisat este **No image loaded**.

Verificam daca comanda primita are argumenetele valide (sub forma a 4 numere). In caz afirmativ, extragem valorile acestora din buffer cu ajutorul functiei *sscanf*.

Aranjam in ordinea corecta coordonatele punctelor primite, tratand separat fiecare caz de pozitionare incorecta a indicilor.

Daca indicii primiti sunt invalizi, vom afisa mesajul **Invalid set of coordinates**.

Actualizam dimensiunile din structura (**latimea** si **inaltimea** selectiei, precum si **coordonatele de start** (x_st si y_st).

Afisam statusul **Selected < x1 > < y1 > < x2 > < y2 >**.


## SELECT ALL

Readuce zona de selectie la intreaga imagine.

In cazul in care nu avem nicio imagine incarcata in memorie, afisam mesajul **No image loaded**.

Daca, insa, avem o imagine, reactualizam dimensiunile selectiei, pentru a corespunde celor ale intregii imagini (setam x si y start pe 0 si copiem latimea si inaltimea).

Afisam statusul de indeplinire a sarcinii, **Selected ALL**.


## HISTOGRAM < x > < y >

Afiseaza **histograma** imaginii, folosind maxim **x stelute si y bin-uri**. Se aplica doar pe imagini grayscale.

Incepem prin a calcula vectorul de frecvente al valorilor pixelilor din imagine, numit *histogram*.

Computam lungimea unui bin (256 / y).

Dupa care, grupam pixelii consecutivi in secvente de aceasta lungime si facem suma frecventelor lor, sume pe care le stocam in vectorul *bins*.

Calculam maximul din vectorul *bins*, dupa care, calculam numarul de stelute pentru fiecare bin in parte, folosindu-ne de formula descrisa in cerinta temei.

In final, afisam histograma.


## EQUALIZE

Realizeaza **egalizarea** unei imagini alb-negru.

Daca nu exista nicio imagine incarcata in memorie, mesajul afisat este **No image loaded**.
Daca imaginea este color, afisam mesajul **Black and white image needed**.

Calculam aria imaginii, stocata in variabila *area*.
Alocam memorie vectorului *h* si ii setam toate valorile pe 0.
Construim vectorul de frecvente asociat valorilor pixelilor din matrice (*h*).
Calculam minimul din acest vector.

Dupa care, calculam fiecare valoare in parte, utilizand formula descrisa in cerinta temei si folosindu-ne de functia **clamp***.
Actualizam valorile din matrice si eliberam memoria aferenta vectorului *h*.

Afisam mesajul de finalizare cu succes a operatiei, **Equalize done**.


## ROTATE < unghi >

Face rotirea selectiei curente, intr-o anumita directie, dupa un numar de grade.

In primul rand, stabilim daca unghiul primit ca argument este valid (multiplu de 90, de pana in 360, inclusiv). Daca nu este, afisam mesajul **Unsupported rotation angle**.
Daca selectia defineste intreaga imagine, apelam functia separata *rotate_all*. In caz contrar, verificam daca selectia facuta este patratica.
Calculam valoarea variabilei *sign*, ce poate fi:
 - -1 - pentru stanga, respectiv
 -  +1 - pentru dreapta, 
pentru a stabili directia in care trebuie rotita imaginea.

In mod similar, calculam *rotation_count*, ce ne spune de cate ori imaginea trebuie rotita cu 90 de grade.
Stabilim numarul de canale dupa care vom face rotatia:
 - 1 - pentru grayscale
 - 3 - pentru color
Dupa care, rotim imaginea in conformitate cu variabilele mai sus definite, ajutandu-ne de algoritmul de rotatie descris in cele doua subprograme, *rotate_right* si *rotate_left*.

Daca operatia s-a efectuat cu succes, afisam mesajul **Rotated < unghi >**.


 ## CROP
 Reduce imaginea la cea cuprinsa intre parametrii selectiei curente.
 
In cazul in care nu avem nicio imagine incarcata in memorie, afisam mesajul **No image loaded**.

Stabilim numarul de canale (directii) pe care vom avea de lucrat, in functie de formatul imaginii (1 pentru PGM, respectiv 3 pentru PPM).

Alocam memorie pentru o matrice auxiliara, in care vom stoca partea din matrice ramasa in urma selectiei.
Eliberam memoria matricii vechi si redirectionam pointerul asociat ei catre matricea nou creata.
Actualizam dimensiunile noii matrice cu cele ale selectiei, si resetam x_st si y_st pe (0, 0).

Afisam mesajul **Image cropped**.


## APPLY < PARAMETRU >

Functia aplica un filtru imaginii.

Daca nu exista nicio imagine incarcata in memorie, mesajul afisat este **No image loaded**.
Este o functie ce poate fi aplicata doar imaginilor color. Daca nu este astfel, vom afisa mesajul **Easy, Charlie Chaplin**.

Parametrul poate fi **EDGE, SHARPEN, BLUR** sau **GAUSSIAN_BLUR**. Fiecare dintre aceste filtre are asociata o matrice nucleu, numita **kernel**, definite in cadrul functiei.
Apelam functia *apply_parameter* cu kernel-ul asociat argumentului.

Alocam memorie matricii auxiliare.
Calculam valoarea fiecarui pixel in parte, prin inmultirea kernel-ului cu matricea formata din pixelul curent si vecinii sai, tratand separat cazul in care elementul se afla pe marginea matricii, iar rezultatul va fi stocat in *temp*.

Copiem valorile din *temp* pe elementele omoloage din matricea initiala si eliberam memoria asociata lui *temp*.

Afisam mesajul **APPLY < PARAMETER > done**.


## SAVE < nume_fisier > [ascii]
Salveaza imaginea curenta in fisierul nume_fisier, in format text/binar.

 Daca nu exista nicio imagine incarcata in memorie, mesajul afisat este **No image loaded**.
 Daca parametrul ascii exista, o vom salva in format text, in caz contrar, in format binar.
 
 In functie de acest parametru, actualizam cifra magica si deschidem fisierul pentru scriere (t/b).
 
 Printam cifra magica, latimea, inaltimea, max_value si valorile din matrice.
 Dupa care, inchidem fisierul si afisam mesajul **Saved < nume_fisier >**.


## EXIT
 Daca nu exista nicio imagine incarcata in memorie, mesajul afisat este **No image loaded**.
 Dealoca toate resursele imaginii si actualizeaza statusul structurii, is_loaded, pe 0.


## *Functii suplimentare
## CLAMP

Aduce valoarea primita drept argument la un anumit interval, [min, max], prin comparari, astfel:
 - daca x < min, atunci x = min;
 - daca x > max, atunci x = max;
 - altfel, x isi pastreaza valoarea.

## is_edge

Verifica daca un element este situat pe marginea matricii.
